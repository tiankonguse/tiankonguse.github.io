<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>图片识别</title>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script src="heic2any.min.js"></script>
</head>

<body>
    <div style="position: fixed;top: 5px;left: 5px;background: white;">
        <span lan_id="bc">选择图片</span> <input type="file" id="pictureChange" />
        <button id="button-gray">置灰</button>
        <button id="button-invert">反转</button>
        <button id="button-fix">修正</button>
        <button id="button-reset">重置</button>
        <br />
        当前颜色: <span id="hovered-color-text">rgba(0, 0, 0, 0)</span><span id="hovered-color">【0123456】</span>
        选择颜色: <span id="selected-color-text">rgba(0, 0, 0, 0)</span><span id="selected-color">【0123456】</span>
        灰度颜色: <span id="gray-color-text">rgba(0, 0, 0, 0)</span><span id="gray-color">【0123456】</span>
        <br />
        <span id="color-similarity">
            白色相似度: <span class="white">0</span>;
            黑色相似度: <span class="black">0</span>;
            红色相似度: <span class="red">0</span>;
            橙色相似度: <span class="orange">0</span>;
            蓝色相似度: <span class="blue">0</span>;

    </div>
    </div>
    <div style="margin-top: 60px;">
        <canvas id="canvas"></canvas>
    </div>
</body>
<script type="text/javascript">
    const canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var base = {
        "imageData": []
    };
    const $canvas = $("#canvas");
    const hoveredColor = document.getElementById("hovered-color");
    const selectedColor = document.getElementById("selected-color");
    const grayColor = document.getElementById("gray-color");
    const hoveredColorText = document.getElementById("hovered-color-text");
    const selectedColorText = document.getElementById("selected-color-text");
    const grayColorText = document.getElementById("gray-color-text");
    const colorSimilarity = $("#color-similarity");


    const whiteColor = [240, 240, 240]
    const blackColor = [50, 50, 50]
    const blueColor = [70, 85, 190]
    const redColor = [190, 100, 120]
    const orangeColor = [220, 150, 100]
    const colors = { "red": redColor, "orange": orangeColor, "blue": blueColor, "black": blackColor, "white": whiteColor };


    $("#button-invert").click(function () {
        invert();
    });
    $("#button-gray").click(function () {
        grayscale();
    });

    $("#button-fix").click(function () {
        minFix();
    });
    $("#button-reset").click(function () {
        ctx.putImageData(base.imageData, 0, 0);
    });

    const invert = () => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i]; // red
            data[i + 1] = 255 - data[i + 1]; // green
            data[i + 2] = 255 - data[i + 2]; // blue
            data[i + 3] = 255;
        }
        ctx.putImageData(imageData, 0, 0);
    };


    const grayscale = () => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            let avg = parseInt((data[i] + data[i + 1] + data[i + 2]) / 3);
            if (avg < 64) {
                avg = 0;
            } else if (avg > 192) {
                avg = 255;
            } else {
                avg = 0;
            }
            data[i] = avg; // red
            data[i + 1] = avg; // green
            data[i + 2] = avg; // blue
            data[i + 3] = 255; // 
        }
        ctx.putImageData(imageData, 0, 0);

        let dots = []
        const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        let BfsScan = function (x, y) {
            let sta = []

            const center = (x * canvas.width + y) * 4;
            data[center] = 254;
            dots.push([x, y]);
            sta.push([x, y]);

            while (sta.length > 0) {
                const xy = sta.pop();
                const x = xy[0];
                const y = xy[1];

                for (let i = 0; i < dirs.length; i++) {
                    const X = x + dirs[i][0];
                    const Y = y + dirs[i][1];
                    if (X < 0 || X > canvas.height || Y < 0 || Y > canvas.width) {
                        continue;
                    }
                    const center = (X * canvas.width + Y) * 4;
                    if (data[center] != 255) {
                        continue;
                    }
                    data[center] = 254;
                    dots.push([X, Y]);
                    sta.push([X, Y]);
                }
            }

        }
        let ShowEdge = function () {
            for (let i = 0; i < dots.length; i++) {
                dots[i] = turf.point(dots[i])
            }
            let points = turf.featureCollection(dots);
            var hull = turf.convex(points); // 凸多边形
            // hull = turf.concave(points, { units: 'degrees', maxEdge: 20 }); // 凹多边形
            var simplified = turf.simplify(hull, { tolerance: 0.01, highQuality: true, mutate: true });

            const tmp = hull.geometry.coordinates[0];
            ctx.strokeStyle = "rgba(255,0,0,1)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(tmp[0][1], tmp[0][0]);
            for (let i = 1; i < tmp.length; i++) {
                ctx.lineTo(tmp[i][1], tmp[i][0]);
            }
            ctx.closePath();
            ctx.stroke();
        }

        for (let row = 0; row < canvas.height; row++) {
            for (let col = 0; col < canvas.width; col++) {
                const center = (row * canvas.width + col) * 4;
                if (data[center] == 255) {
                    BfsScan(row, col);
                    if (dots.length > 5000) {
                        ShowEdge();
                    } else { // 无效白板，删除
                        // for (let i = 0; i < dots.length; i++) {
                        //     const xy = dots[i];
                        //     const x = xy[0];
                        //     const y = xy[1];
                        //     const center = (x * canvas.width + y) * 4;
                        //     for (let j = 0; j < 3; j++) {
                        //         data[center + j] = 0;
                        //     }
                        // }
                    }
                    dots = []
                }

            }
        }

    };
    const minFix = () => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i + 3] = 255; //关闭透明度
        }

        // 先把颜色分配
        for (let i = 0; i < data.length; i += 4) {
            for (let j = 0; j < 3; j++) {
                data[i + j] = parseInt((data[i + j]) / 50) * 50;
            }

            const selectColor = [data[i], data[i + 1], data[i + 2]];

            for (let key in colors) {
                if (Distance(selectColor, colors[key]) < 70) {
                    for (let j = 0; j < 3; j++) {
                        data[i + j] = colors[key][j];
                    }
                }
            }

        }


        // let fixDot = 1;
        // while (fixDot > 0) {
        //     fixDot = 0;
        //     const toColor = function (data) {
        //         const rgba = `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] / 255})`;
        //         return rgba;
        //     }
        //     for (let row = 1; row < canvas.height - 1; row++) {
        //         for (let col = 1; col < canvas.width - 1; col++) {
        //             const center = (row * canvas.width + col) * 4;

        //             let counts = {};
        //             const addCount = function (p) {
        //                 const color = toColor(p);
        //                 if (!counts.hasOwnProperty(color)) {
        //                     counts[color] = []
        //                 }
        //                 counts[color].push(p);
        //                 return color
        //             }
        //             const centerColor = addCount(center);

        //             let sides = [];
        //             for (let i = -1; i <= 1; i++) {
        //                 for (let j = -1; j <= 1; j++) {
        //                     if (i == 0 && j == 0) continue;
        //                     const side = ((row + i) * canvas.width + (col + j)) * 4;
        //                     addCount(side);
        //                 }
        //             }

        //             for (const k in counts) {
        //                 if (counts[k].length >= 3 && centerColor != k) {
        //                     fixDot++;
        //                     const side = counts[k][0]
        //                     for (let i = 0; i < 3; i++) {
        //                         data[center + i] = data[side + i]
        //                     }
        //                 }
        //             }
        //         }
        //     }
        //     console.log("修复像素个数 ", fixDot);
        // }

        ctx.putImageData(imageData, 0, 0);
    };
    function pick(event, destination, destinationText) {
        const bounding = canvas.getBoundingClientRect();
        const x = event.clientX - bounding.left;
        const y = event.clientY - bounding.top;
        const pixel = ctx.getImageData(x, y, 1, 1);
        const data = pixel.data;

        const rgba = `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] / 255})`;
        destination.style.color = rgba;
        destinationText.textContent = rgba;

        const gray = parseInt((data[0] + data[1] + data[2]) / 3);
        const grayRgba = `rgba(${gray}, ${gray}, ${gray}, ${data[3] / 255})`;
        grayColor.style.color = grayRgba;
        grayColorText.textContent = grayRgba;

        const selectColor = [data[0], data[1], data[2]];
        for (let key in colors) {
            colorSimilarity.find("." + key).text(parseInt(Distance(selectColor, colors[key])));
        }

        return rgba;
    }
    // canvas.addEventListener("mousemove", (event) => pick(event, hoveredColor, hoveredColorText));
    canvas.addEventListener("click", (event) => pick(event, selectedColor, selectedColorText));

    function Distance(vec1, vec2) {
        let sum = 0;
        for (let i = 0; i < vec1.length; i++) {
            const d = Math.abs(vec1[i] - vec2[i]);
            sum += d * d;
        }
        return Math.sqrt(sum);
    }
    function cosineSimilarity(vec1, vec2) {
        const calcVectorSize = function (vec) {
            return Math.sqrt(vec.reduce((accum, curr) => accum + Math.pow(curr, 2), 0));
        };
        const dotProduct = vec1.map((val, i) => val * vec2[i]).reduce((accum, curr) => accum + curr, 0);
        const vec1Size = calcVectorSize(vec1);
        const vec2Size = calcVectorSize(vec2);

        return dotProduct / (vec1Size * vec2Size);
    };

    function dotp(x, y) {
        function dotp_sum(a, b) {
            return a + b;
        }
        function dotp_times(a, i) {
            return x[i] * y[i];
        }
        return x.map(dotp_times).reduce(dotp_sum, 0);
    }

    function cosineSimilarity2(A, B) {
        var similarity = dotp(A, B) / (Math.sqrt(dotp(A, A)) * Math.sqrt(dotp(B, B)));
        return similarity;
    }

    $("#pictureChange").change(function (e) {
        var blob = e.target.files[0];
        console.log("select file: ", blob);
        if (blob.type == "image/heic") {
            // https://stackoverflow.com/questions/46754688/convert-heic-to-jpg-using-php-or-js
            // https://github.com/alexcorvi/heic2any/blob/master/docs/getting-started.md
            heic2any({
                blob: blob,
                toType: "image/png",
            }).then(function (resultBlob) {
                console.log("heic trans to png: ", resultBlob);
                LoadImg(resultBlob);
            }).catch(function (x) {
                console.log("catch ", x);
            });
        } else {
            LoadImg(blob);
        }

    })

    function LoadImg(blob) {
        var fr = new FileReader();
        fr.readAsDataURL(blob);
        fr.onloadend = function (e) {
            console.log("file load finish", e);
            var base64Data = e.target.result;
            ShowImg(base64Data)
        }
    }

    function ShowImg(data) {

        var img = new Image();
        img.src = data;
        img.onload = function () {
            console.log("img load finish");
            // img.width /= 3;
            // img.height /= 3;
            $canvas.attr("width", img.width)
            $canvas.attr("height", img.height)
            ctx.drawImage(img, 0, 0, img.width, img.height);
            base.imageData = ctx.getImageData(0, 0, img.width, img.height);
            // console.log(base.imageData.data, base.imageData.width, base.imageData.height);

        };
    }
    function showCode(code) {
        $("#result").append("<li>" + code + "</li>")
    }
</script>

</html>