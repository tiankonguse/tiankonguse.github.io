<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>图片识别</title>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script src="heic2any.min.js"></script>
</head>

<body>
    <div style="position: fixed;top: 5px;left: 5px;background: white;">
        <span lan_id="bc">选择图片</span> <input type="file" id="pictureChange" />
        <button id="button-gray">置灰</button>
        <button id="button-invert">反转</button>
        <button id="button-fix">修正</button>
        <button id="button-reset">重置</button>
        <br />
        当前颜色: <span id="hovered-color-text">rgba(0, 0, 0, 0)</span><span id="hovered-color">【0123456】</span>
        选择颜色: <span id="selected-color-text">rgba(0, 0, 0, 0)</span><span id="selected-color">【0123456】</span>
        灰度颜色: <span id="gray-color-text">rgba(0, 0, 0, 0)</span><span id="gray-color">【0123456】</span>
        <br />
        <span id="color-similarity">
            白色相似度: <span class="white">0</span>;
            黑色相似度: <span class="black">0</span>;
            红色相似度: <span class="red">0</span>;
            橙色相似度: <span class="orange">0</span>;
            蓝色相似度: <span class="blue">0</span>;
            桌子相似度: <span class="board">0</span>;

    </div>
    </div>
    <div style="margin-top: 60px;">
        <canvas id="canvas"></canvas>
    </div>
</body>
<script type="text/javascript">
    const canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var base = {
        "imageData": []
    };
    const $canvas = $("#canvas");
    const hoveredColor = document.getElementById("hovered-color");
    const selectedColor = document.getElementById("selected-color");
    const grayColor = document.getElementById("gray-color");
    const hoveredColorText = document.getElementById("hovered-color-text");
    const selectedColorText = document.getElementById("selected-color-text");
    const grayColorText = document.getElementById("gray-color-text");
    const colorSimilarity = $("#color-similarity");


    const whiteColor = [240, 240, 240]
    const blackColor = [50, 50, 50]
    const blueColor = [70, 85, 190]
    const redColor = [190, 100, 120]
    const orangeColor = [220, 150, 100]
    const boardColor = [205, 180, 130]
    const colors = { "red": redColor, "orange": orangeColor, "blue": blueColor, "black": blackColor, "white": whiteColor, "board": boardColor };


    $("#button-invert").click(function () {
        invert();
    });
    $("#button-gray").click(function () {
        grayscale();
    });

    $("#button-fix").click(function () {
        minFix();
    });
    $("#button-reset").click(function () {
        ctx.putImageData(base.imageData, 0, 0);
    });

    const invert = () => {
        const imageData = base.imageData;
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i]; // red
            data[i + 1] = 255 - data[i + 1]; // green
            data[i + 2] = 255 - data[i + 2]; // blue
            data[i + 3] = 255;
        }
        ctx.putImageData(imageData, 0, 0);
    };

    let BfsScan = function (row, col, oldColor, newColor, dots, data) {
        const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        let sta = []

        const center = (row * canvas.width + col) * 4;
        data[center] = newColor;
        dots.push([row, col]);
        sta.push([row, col]);

        while (sta.length > 0) {
            const xy = sta.pop();
            const row = xy[0];
            const col = xy[1];

            for (let i = 0; i < dirs.length; i++) {
                const ROW = row + dirs[i][0];
                const COL = col + dirs[i][1];
                if (ROW < 0 || ROW >= canvas.height || COL < 0 || COL >= canvas.width) {
                    continue;
                }
                const center = (ROW * canvas.width + COL) * 4;
                if (data[center] != oldColor) {
                    continue;
                }
                data[center] = newColor;
                dots.push([ROW, COL]);
                sta.push([ROW, COL]);
            }
        }
        return dots;
    }
    const grayscale = () => {
        const imageData = base.imageData;
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            let avg = parseInt((data[i] + data[i + 1] + data[i + 2]) / 3);
            if (avg < 64) {
                avg = 0;
            } else if (avg > 192) {
                avg = 255;
            } else {
                avg = 0;
            }
            data[i] = avg; // red
            data[i + 1] = avg; // green
            data[i + 2] = avg; // blue
            data[i + 3] = 255; // 
        }
        ctx.putImageData(imageData, 0, 0);


        let ShowEdge = function (dots) {
            for (let i = 0; i < dots.length; i++) {
                dots[i] = turf.point(dots[i])
            }
            let points = turf.featureCollection(dots);
            // https://turfjs.fenxianglu.cn/category/transformation/convex.html
            var hull = turf.convex(points); // 凸多边形
            // hull = turf.concave(points, { units: 'degrees', maxEdge: 20 }); // 凹多边形
            // https://turfjs.fenxianglu.cn/category/transformation/simplify.html
            var simplified = turf.simplify(hull, { tolerance: 5, highQuality: true, mutate: true });

            var area = turf.area(simplified);


            const tmp = hull.geometry.coordinates[0];
            ctx.strokeStyle = "rgba(255,0,0,1)";
            ctx.fillStyle = "rgba(0, 255, 0, 1)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(tmp[0][1], tmp[0][0]);
            var edges = []
            for (let i = 1; i < tmp.length; i++) {
                ctx.lineTo(tmp[i][1], tmp[i][0]);

                ctx.fillRect(tmp[i][1], tmp[i][0], 10, 10);

                edges.push(turf.length(turf.lineString([tmp[i - 1], tmp[i]])));
            }
            console.log(simplified.length, tmp, edges, area);
            ctx.closePath();
            ctx.stroke();


        }

        for (let row = 0; row < canvas.height; row++) {
            for (let col = 0; col < canvas.width; col++) {
                const center = (row * canvas.width + col) * 4;
                if (data[center] == 255) {
                    let dots = []
                    BfsScan(row, col, 255, 254, dots, data);
                    if (dots.length > 5000) {
                        ShowEdge(dots);
                    } else { // 无效白板，删除
                        // for (let i = 0; i < dots.length; i++) {
                        //     const xy = dots[i];
                        //     const x = xy[0];
                        //     const y = xy[1];
                        //     const center = (x * canvas.width + y) * 4;
                        //     for (let j = 0; j < 3; j++) {
                        //         data[center + j] = 0;
                        //     }
                        // }
                    }
                    dots = []
                }

            }
        }

    };
    const minFix = () => {
        const imageData = base.imageData;
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i + 3] = 255; //关闭透明度
        }

        // 先把颜色分配
        for (let i = 0; i < data.length; i += 4) {
            // for (let j = 0; j < 3; j++) {
            //     data[i + j] = parseInt((data[i + j]) / 50) * 50;
            // }

            const selectColor = [data[i], data[i + 1], data[i + 2]];

            for (let key in colors) {
                if (Distance(selectColor, colors[key]) < 70) {
                    for (let j = 0; j < 3; j++) {
                        data[i + j] = colors[key][j];
                    }
                }
            }
        }
        console.log("颜色归类");
        ctx.putImageData(imageData, 0, 0);

        for (let i = 0; i < data.length; i += 4) { // 转化为黑白
            let avg = parseInt((data[i] + data[i + 1] + data[i + 2]) / 3);
            if (avg < 64) {
                avg = 0;
            } else if (avg > 192) {
                avg = 255;
            } else {
                avg = 0;
            }
            data[i] = avg; // red
            data[i + 1] = avg; // green
            data[i + 2] = avg; // blue
            data[i + 3] = 255; // 
        }
        console.log("转化为黑白");
        ctx.putImageData(imageData, 0, 0);

        // bfs 所有黑色区域，找到最大的，标记为底色
        const oldColor = 0;
        const newColor = 100
        const midColor = 150
        let boardDots = []
        for (let row = 1; row < canvas.height - 1; row++) {
            for (let col = 1; col < canvas.width - 1; col++) {
                const center = (row * canvas.width + col) * 4;
                if (data[center] != oldColor) continue;
                let tmpDots = []
                BfsScan(row, col, oldColor, newColor, tmpDots, data);
                if (tmpDots.length > boardDots.length) {
                    boardDots = tmpDots
                }

            }
        }

        for (let row = 0; row < canvas.height; row++) {
            for (let col = 0; col < canvas.width; col++) {
                const center = (row * canvas.width + col) * 4;
                if (data[center] == newColor) {
                    data[center] = oldColor;
                }
            }
        }
        for (let i = 0; i < boardDots.length; i++) { // 恢复黑色
            const xy = boardDots[i];
            const ROW = xy[0]
            const COL = xy[1]
            const center = (ROW * canvas.width + COL) * 4;
            data[center] = newColor
        }



        console.log("背景染色", boardDots.length);
        ctx.putImageData(imageData, 0, 0);
        // 目前为止，背景是1


        let midDots = []
        const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        for (let j = 0; j < boardDots.length; j++) { // 恢复黑色
            const xy = boardDots[j];
            const row = xy[0]
            const col = xy[1]
            for (let i = 0; i < 4; i++) {
                const ROW = row + dirs[i][0];
                const COL = col + dirs[i][0];
                if (ROW < 0 || ROW >= canvas.height || COL < 0 || COL >= canvas.width) {
                    continue
                }
                const center = (ROW * canvas.width + COL) * 4;
                if (data[center] != newColor && data[center] != midColor) {
                    data[center] = midColor
                    midDots.push([ROW, COL])
                }
            }
        }
        console.log("初始待处理像素", midDots.length);

        // TODO: 需要使用图论来优化，每次只搜索有变更的待处理像素
        const DIS = 20;
        let fixDot = DIS;
        while (fixDot >= DIS) {
            fixDot = 0;

            let tmpDots = []
            for (let k = 0; k < midDots.length; k++) {
                const row = midDots[k][0]
                const col = midDots[k][1]
                const center = (row * canvas.width + col) * 4;
                if (data[center] == newColor) continue;

                let flag = 0

                for (let dis = DIS; dis >= 5; dis--) {
                    let counts = 0;
                    for (let i = -dis; i <= dis; i++) {
                        for (let j = -dis; j <= dis; j++) {
                            if (row + i < 0 || row + i >= canvas.height || col + j < 0 || col + j >= canvas.width) {
                                continue
                            }
                            const side = ((row + i) * canvas.width + (col + j)) * 4;
                            if (data[side] == newColor) {
                                counts++;
                            }
                        }
                    }

                    if (counts >= (dis * 2 + 1) * (dis * 2 + 1) * 0.8) { // 一个角覆盖率是 3/4，所以至少0.75
                        flag = 1
                        break;
                    }
                }

                if (flag) {
                    data[center] = newColor;
                    data[center + 1] = 0;
                    data[center + 2] = 0;
                    fixDot++;
                    boardDots.push([row, col]);


                    for (let i = 0; i < 4; i++) {
                        const ROW = row + dirs[i][0];
                        const COL = col + dirs[i][0];
                        if (ROW < 0 || ROW >= canvas.height || COL < 0 || COL >= canvas.width) {
                            continue
                        }
                        const center = (ROW * canvas.width + COL) * 4;
                        if (data[center] == newColor) continue;
                        if (data[center] == midColor) continue;
                        data[center] = midColor
                        tmpDots.push([ROW, COL])
                    }

                } else {
                    tmpDots.push([row, col])
                }
            }
            midDots = tmpDots
            console.log("修复像素个数 ", fixDot, "待处理像素", midDots.length);
            ctx.putImageData(imageData, 0, 0);
        }

        ctx.putImageData(imageData, 0, 0);
    };
    let backColor = 0
    let backDots = []
    function pick(event, destination, destinationText) {
        const bounding = canvas.getBoundingClientRect();
        const imageData = base.imageData;
        const tmpData = imageData.data
        const col = event.clientX - bounding.left;
        const row = event.clientY - bounding.top;
        const center = (row * canvas.width + col) * 4;
        const data = [tmpData[center], tmpData[center + 1], tmpData[center + 2], tmpData[center + 3]];
        const oldColor = data[0];

        if (backDots.length > 0) {
            for (let i = 0; i < backDots.length; i++) {
                const xy = backDots[i];
                const ROW = xy[0]
                const COL = xy[1]
                const center = (ROW * canvas.width + COL) * 4;
                tmpData[center] = backColor
                tmpData[center + 1] = backColor
                tmpData[center + 2] = backColor
            }
            ctx.putImageData(imageData, 0, 0);
            console.log("reset", backColor, row, col, event.clientX, event.clientY, event, bounding);
            backColor = 0
            backDots = []
        } else {
            backColor = oldColor;
            let newColor = 100;
            // const imageData = base.imageData;
            // const tmpData = imageData.data
            BfsScan(row, col, oldColor, newColor, backDots, tmpData);
            console.log("select", oldColor, backDots.length, row, col, event.clientX, event.clientY, event, bounding);

            for (let i = 0; i < backDots.length; i++) {
                const xy = backDots[i];
                const ROW = xy[0]
                const COL = xy[1]
                const center = (ROW * canvas.width + COL) * 4;
                tmpData[center] = newColor
                tmpData[center + 1] = 0
                tmpData[center + 2] = 0
            }
            ctx.putImageData(imageData, 0, 0);
        }

        const rgba = `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] / 255})`;
        destination.style.color = rgba;
        destinationText.textContent = rgba;

        const gray = parseInt((data[0] + data[1] + data[2]) / 3);
        const grayRgba = `rgba(${gray}, ${gray}, ${gray}, ${data[3] / 255})`;
        grayColor.style.color = grayRgba;
        grayColorText.textContent = grayRgba;

        const selectColor = [data[0], data[1], data[2]];
        for (let key in colors) {
            colorSimilarity.find("." + key).text(parseInt(Distance(selectColor, colors[key])));
        }

        return rgba;
    }
    // canvas.addEventListener("mousemove", (event) => pick(event, hoveredColor, hoveredColorText));
    canvas.addEventListener("click", (event) => pick(event, selectedColor, selectedColorText));

    function Distance(vec1, vec2) {
        let sum = 0;
        for (let i = 0; i < vec1.length; i++) {
            const d = Math.abs(vec1[i] - vec2[i]);
            sum += d * d;
        }
        return Math.sqrt(sum);
    }
    function cosineSimilarity(vec1, vec2) {
        const calcVectorSize = function (vec) {
            return Math.sqrt(vec.reduce((accum, curr) => accum + Math.pow(curr, 2), 0));
        };
        const dotProduct = vec1.map((val, i) => val * vec2[i]).reduce((accum, curr) => accum + curr, 0);
        const vec1Size = calcVectorSize(vec1);
        const vec2Size = calcVectorSize(vec2);

        return dotProduct / (vec1Size * vec2Size);
    };

    function dotp(x, y) {
        function dotp_sum(a, b) {
            return a + b;
        }
        function dotp_times(a, i) {
            return x[i] * y[i];
        }
        return x.map(dotp_times).reduce(dotp_sum, 0);
    }

    function cosineSimilarity2(A, B) {
        var similarity = dotp(A, B) / (Math.sqrt(dotp(A, A)) * Math.sqrt(dotp(B, B)));
        return similarity;
    }

    $("#pictureChange").change(function (e) {
        var blob = e.target.files[0];
        console.log("select file: ", blob);
        if (blob.type == "image/heic") {
            // https://stackoverflow.com/questions/46754688/convert-heic-to-jpg-using-php-or-js
            // https://github.com/alexcorvi/heic2any/blob/master/docs/getting-started.md
            heic2any({
                blob: blob,
                toType: "image/png",
            }).then(function (resultBlob) {
                console.log("heic trans to png: ", resultBlob);
                LoadImg(resultBlob);
            }).catch(function (x) {
                console.log("catch ", x);
            });
        } else {
            LoadImg(blob);
        }

    })

    function LoadImg(blob) {
        var fr = new FileReader();
        fr.readAsDataURL(blob);
        fr.onloadend = function (e) {
            console.log("file load finish", e);
            var base64Data = e.target.result;
            ShowImg(base64Data)
        }
    }

    function ShowImg(data) {

        var img = new Image();
        img.src = data;
        img.onload = function () {
            console.log("img load finish");
            // img.width /= 3;
            // img.height /= 3;
            $canvas.attr("width", img.width)
            $canvas.attr("height", img.height)
            ctx.drawImage(img, 0, 0, img.width, img.height);
            base.imageData = ctx.getImageData(0, 0, img.width, img.height);
            // console.log(base.imageData.data, base.imageData.width, base.imageData.height);

        };
    }
    function showCode(code) {
        $("#result").append("<li>" + code + "</li>")
    }
</script>

</html>