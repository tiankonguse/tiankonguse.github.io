---   
layout:     post  
title:  设计模式之创建型模式     
description: 创建对象的模式，有单例、原型、工厂、抽象工厂、生成器五大模式。  
keywords: 程序人生,项目实战  
tags: [程序人生,项目实战]    
categories: [程序人生]  
updateData:  2022-01-22 23:01:00  
published: true  
---  



![创建型模式](https://res2022.tiankonguse.com/images/2022/01/24/006.png) 


## 零、背景  


之前分享了两个设计模式《[观察者模式](https://mp.weixin.qq.com/s/jwjkkRQjQUoV49jQumViuw)》和《[迭代器模式](https://mp.weixin.qq.com/s/cRIzY0s-GDGxXnNRbLgk7A)》。  


在选择下一个要分享的设计模式时，发现创建型设计模式都比较简单，一篇文章介绍的话太简单了。  


于是计划使用一篇文章把创建型设计模式全部介绍了。  


创建型模式主要介绍该如何创建对象，包括单例、原型、工厂、抽象工厂、生成器五大模式。  


## 一、单例模式


场景：保证一个类只有一个实例，并提供一个访问该实例的全局方法。  


实现方式：不提供公有的构造函数、复制构造函数、赋值函数，通过 static 函数获取类的唯一实例。  


缺点：存在并发问题    


![单例](https://res2022.tiankonguse.com/images/2022/01/24/001.png)  

  


## 二、原型模式


场景：能够复制已有的对象，而又无需了解对象的细节。  


实现方式：增加一个 clone 函数。  
具体的实现逻辑与复制构造函数或赋值函数类似。  
不过原型模式常用于多态，即父类不关心子类的细节，就可以复制出一个一模一样的子类来。  


缺点：深 copy 时，如果有循环引用，就会死循环。  


![原型模式](https://res2022.tiankonguse.com/images/2022/01/24/002.png) 


## 三、工厂模式


场景：父类中提供一个创建对象的方法，允许子类决定创建的具体对象。  


好处：接口与细节解耦，调用工厂后，工厂自动根据创建相关的对象。  


缺点：客户端写一堆 if else  预先创建出自己需要的具体工厂，这个工厂再创建具体的对象。  
 

对比：与原型看起来很像。  
原型是创建一个自己并复制数据。  
工厂是创建一个具体的其他实例。  



![工厂模式](https://res2022.tiankonguse.com/images/2022/01/24/003.png) 


## 四、抽象工厂  


场景：与工厂模式类似，工厂模式只创建一个子类，抽象工厂可以创建多个子类。    


缺点：创建抽象工厂时，依旧需要写一堆 if else。   


![抽象工厂](https://res2022.tiankonguse.com/images/2022/01/24/004.png) 


## 五、生成器模式  


场景：将复杂的对象拆分为若干子对象，然后允许动态选择子对象，组装出不同的对象。  


好处：类似于搭积木，按需拼出一个对象。  


缺点：搭建积木的过程依旧是一堆 if else 或者一堆函数调用。  


![生成器模式](https://res2022.tiankonguse.com/images/2022/01/24/005.png) 


## 六、最后  


创建型设计模式比较简单。  


实际工作中，用的最多的就是单例和工厂模式。  


对于工厂模式，为每个类封装一个工厂，会显得过于冗余，即有点过度设计。  


所以，我们实际项目中，会采用一种简单工厂模式的策略，算是对工厂模式的简化。  


这样，只需要一层 if else，工厂类就可以直接创建具体的子类。  
而不像工厂模式那样，if else 先创建一个中间类，中间类再创建具体的子类。  



你们的实际项目中，有用到生成器模式、原型模式、抽象工厂模式吗？  



《完》  


-EOF-  



本文公众号：天空的代码世界  
个人微信号：tiankonguse  
公众号ID：tiankonguse-code  
知识星球：不止算法  

