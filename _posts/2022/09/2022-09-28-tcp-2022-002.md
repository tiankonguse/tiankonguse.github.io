---   
layout:     post  
title: 2022 腾讯程序设计竞赛（二）
description: 作为旧时代的残党，新世界里没有能承载我的船。  
keywords: 程序人生  
tags: [程序人生]    
categories: [程序人生]  
updateData:  2022-09-28 21:30:00  
published: false  
---  


## 零、背景  


这周某天晚上参加了腾讯举办的 2022 TPC 程序设计竞赛第二场比赛。  


比赛结束后，再次意识到，新时代早就到来了。  


我是十几年前在大学里认识并加入 ACM 的，那时在大学里都是边做项目边参加比赛，不像新时代的选手，系统的学习了各种算法，并刷了很多题。  


现如今，新时代随便一个铜牌选手，都比旧时代的金银牌选手厉害了。  



自己作为旧时代的残党，新世界里没有能承载我的船。  



看下题解吧。  


## 一、听歌  


题意：歌单中有 n 首歌曲，每首歌有自己的时长。  
播放器是按歌单循环播放的。  


现在有两个操作。  


1）歌单中追加一首歌。  
2）听歌 x 分钟后，问在听哪首歌？  


最优思路：  


预处理出歌单的前缀和。  
对于操作1，歌单追增一首歌，前缀和也更新下。  


对于操作2，维护一个时间偏移量。  
每次询问时，听多长时间，时间偏移量后移多少。  
之后根据歌单的总时长，取模修正时间偏移量。  
然后二分查找前缀和，判断当前偏移量处于哪首歌里即可。  


复杂度：`O(q * log(n))`  


暴力思路：  


数据范围不大，只需要维护总和。  
查询的时候，使用总和取模，之后循环歌单，判断处于哪首歌。  


复杂度：`O(q * n)`  



注意事项：注意边界问题即可。  


  
## 二、和平精英  


题意：n 个玩家降落在一个数轴上，方向可能朝左或朝右，移动速度为1。  
然后有 m 个空投，位置不会变化，首次遇到空投的玩家可以获得空投，之后空投消失。  


如果相同时间多个玩家同时到达一个空投时，由于会打架而不能获得空投。    
之后玩家继续移动，空投不会消失，可以被后面的玩家获得。  


问最终每个玩家获得了多少个空投。  


最优二分思路：   


先根据玩家的移动方向，划分为两部分，并分别按坐标排序。  
之后枚举每个空投，二分查找左边第一个到达的人和右边第一个到达的人。  
如果左边与右边同时到达，则循环判断下一个人。  
如果没有同时到达，谁先到达谁获得空投。  
如果最后左右都没人了，空投没有获得。  


平均复杂度：`O(n log(m))`  
复杂度退化：如果经常遇到同时到达，则会导致算法退化。  
由于题意保证坐标互补相同，由此决定累计退化 `O(m/2)` 次，复杂度不变。  


暴力枚举思路：    


由于只有 100 个人与 100 个空投，可以暴力计算每个空投谁会遇到。  


枚举每个空投，循环找出所有可能遇到空投的玩家，计算出相遇的时间，存入 map 进行计数。  
循环判断 map，第一个玩家为 1 的人获取空投。  


复杂度：`O(n^2 log(n))`  



## 三、智能杀毒  



题意：有 n 个文件感染病毒了，有另种杀毒方法。  


1）使用万能杀毒：每次只能杀毒一个文件，消耗时间固定。  
2）特效杀毒：使用包含 k 种病毒信息的特效病毒库，可以在总共 ck 的时间内一直清除当前文件中的病毒。  
特效杀毒不会中途停下，除非遇上病毒库中不包含的病毒或没有文件需要杀毒才会结束。每次特效杀毒可以使用与之前不同的病毒库，病毒库的大小上限为 m。  


问杀毒的最短时间以及方案数。  



思路：这道题题意很复杂，比赛的时候理解错题意了。  


特效杀毒包含 k 种病毒信息的含义是，如果一个区间内，不同病毒集合的数量是 k，则可以使用选择这个特效杀毒。  
还有一个限制条件，即特效杀毒不会中途停下。  
含义是区间之后的那个病毒编号，不能属于当前集合，否则，区间会继续扩大。  



明白了题意，就会发现这道题是典型的动态规划题。  


先预处理计算出每个文件向后的 k 种病毒库区间大小。  


预处理方法：k 从小到大分别预处理。  
假设求出 `next[k][i]` 的右边界了，对于 `next[k][i+1]`，可以复用之前的统计数据。  


注意事项：需要使用一个大小为 `10^6`的 数组来统计集合的大小，不能使用 map。  
预处理复杂度： `O(k * n)`  



然后使用动态规划，计算出每个文件处理完的最优时间与方案数。  


状态定义：`dp[i]` 上次操作后，以 i 文件为结尾的最短时间以及方案数。  


对于当前文件 i，可以选择万能杀毒 或者 m 种特效杀毒。  
复杂度: `O(k * n)`  


```
for(int k=1;k<=m;k++){
    int r = next[k][i];
    // dp[i-1] 花费 cost[k] 可以到达 dp[r]
    Update(dp[r], dp[i-1], cost[k]);
}
```


## 四、树.zip  


题意：给一个无根树，问随机的选择 k 条边进行缩边，问剩余叶子的期望数。  


缩边：选择一条边，两边的顶点合并为一个顶点。  



思路：期望题我向来不会的，所以比赛的时候果断放弃。  


后来 tysen 说直接按照期望的最原始定义来做这道题就行了。  
即求出所有叶子的个数，除以所有的方案数，就是叶子的期望数。  


我问怎么求出叶子的个数？  
tysen 说枚举每个顶点在所有方案中作为叶子的方案数即可。  


我思考可一下，发现题意原始的定义确实可以转化为顶点作为叶子的方案数。  


推导逻辑大概如下：  


目标：剩余的叶子的期望数量  
公式：sum(所有方案: 一个方案叶子的个数)/方案总数  
一个方案叶子的个数：sum(所有顶点: 每个顶点是否是叶子)  


```
  sum(所有方案: 一个方案叶子的个数)/方案总数
= sum(所有方案: sum(所有顶点: 每个顶点是否是叶子)) / 方案总数
= sum(所有顶点: sum(所有方案: 每个方案该顶点是否是叶子)) / 方案总数
= sum(所有顶点: 每个顶点作为叶子的方案数) / 方案总数
```


问题转化为求每个顶点作为叶子的方案数了。  


想要解决这个问题，还需要一个启发性思维：对删边做一个定义。  
删除一条边，两个顶点会变成一个，选择哪个是一个问题。  


我起初想使用大小关系来做，却发现不行。  
后来发现可以使用有根数关系来解决这道题。  


删边定义：删除儿子顶点，保留父节点。  


随便选择一个顶点作为根，把无根树转化为有根树。  


对于每个顶点，想要作为叶子节点，根据删边定义，与父节点的边不能删除，所有的子树边都需要删除。  


对于有父节点的顶点，是叶子的方案数是`C(n-1-1-childEdge, k-childEdge)`。  
解释：共有 `n-1`条边，子树的边 childEdge 都需要删除，父节点边不能删除，其他边随意删除。  


对于没有父节点的顶点，其实就是根，需要特殊处理。  
根作为叶子时只能与一个顶点相连，所以共有 `n-1` 中情况。  
假设根与 `v` 节点相连，则除了 v 的子树 与 v 的父节点（根），其他节点都必须删除，而 v 的子树是否要删边按需要决定。  
所以方案数是：`C(childEdge, k-(n-1-childEdge-1)`  


总的方案数是 `C(n, k)` 。  
期望可以通过逆元计算出来了。    



## 五、字符串函数  


题意：`f(s, k)`代表将字符串 s 重复 k 次取长度为 k 的前缀。  


现在给一个字符串 s ，有若干操作。  


1）某个位置的字符进行修改。  
2）问有多少长度为 x 的不同字符串 T，满足 `f(s, 3^1000)=f(t, 3^1000)`。  


思路：  


根据询问操作，可以发现最终的字符串很长很长。  
两个字符串不断的循环，又要相等，那必然存在相同的最小循环节。  


比如 `abcabc` 与 `abcabcabc`， 循环节都是 `abc`， 最终答案才会相同。  


假设询问是存在答案，由于循环节是固定的，长度为 x 的答案也必然是确定的。  
如果 x 可以整除循环节，则答案是 1， 否则答案是 0。  


tysen 提醒，x 是固定的。  
所以不需要求最小的循环节，只需要判断 `gcd(x, n)` 是不是循环节就行了。  


现在已经知道一个长度了，怎么判断是不是循环节呢？  
我突然想到，通过字符串hash 的左移右移，可以`O(1)`时间判断。  


具体来说，循环节长度就是 x， 则 s 有 `n/x` 个循环节。  
如果字符串循环左移 x 位，字符串的 hash 值必然是不变的。  


hash 值定义：从左到右，依次乘以 `B^i`, i 是偏移量。  
这样，把这些值储存在树状数组或线段树里，通过区间查询前缀和即可得到前缀的 hash 值。  


怎么循环右移呢？  
假设 x 位循环节的 hash 值是 pre，整个串的hash值是 h。  
则可以求出前 `n-x` 位的串 hash 值：`h-pre * 2^(n-x)`。  
前 `n-x` 位串右移 x 位再加上 pre ``，预期结果就是整个串的 hash 值。  


公式化简如下，看公式更清晰：  


```
  (h-pre * 2^(n-x)) * 2^x + pre
=  h * 2^x - pre * 2^n + pre
```



## 六、最后  


这场比赛只做出两道题，排名一百多名了。  
还好第一场比赛手速快点，虽然也是两道题，但是进入了五十多名。  
这样两场比赛合起来，综合排名也进入前百名了。  


应该能进入决赛了吧。  


对于决赛，我的目标是不是最后五名就好。  




《完》  


-EOF-  



本文公众号：天空的代码世界  
个人微信号：tiankonguse  
公众号ID：tiankonguse-code  
  

