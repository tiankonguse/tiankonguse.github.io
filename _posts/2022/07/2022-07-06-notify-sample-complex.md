---   
layout:  post  
title: 缓存服务中通知模块的演化  
description: 面对一个问题，引入一个解决方案，就会引入另外一系列问题。  
keywords: 技术人生
tags: [技术人生]    
categories: [技术人生]  
updateData:  2022-07-06 18:13:00  
published: false  
---  


## 零、背景  


我一直负责一个缓存系统。  


缓存系统有一个特点：数据更新时，缓存模块需要尽快感知到数据有变更，然后给读业务方返回最新数据。  


面对这个问题，实现方案也只有一个：通知。  


![](https://res2022.tiankonguse.com/2022/07/06/001.png)  



面对通知这个话题，业界经常对写储存、写缓存、删除缓存三者的选择与先后顺序进行争论。  


由于我们的系统是批量系统，通知的维度与具体缓存数据的维度不在一个层次。  
所以，我们的通知是无法带数据，也无法删除缓存的。
通知只能下发一个可比较的唯一标示，然后通过读触发来比较这个唯一标示来判断数据是否有更新。 



![](https://res2022.tiankonguse.com/2022/07/06/002.png)  



如上图，数据有更新时，写服务需要先得到一个唯一的递增的 seq。  
数据写入到储存时，需要把 seq 也写进去。  
而缓存系统缓存数据时，也需要把 Seq 储存起来。  
数据有更新时，通知把一个 key 的最新 seq 下发到缓存服务储存起来。  
当有请求来的时候，就可以通过通知的 Seq 与缓存的 seq 来判断数据是否有变更。  


## 一、旧系统  


面对上面介绍的方案，实现的时候有两个问题：怎么生成 seq，seq 怎么下发到下缓存服务。  



早在 2016 年，我们继续这样一套通知机制。  


所以我们遵循着简单实现的原则，分别采用了下面的方案。  
生成 Seq: zookeeper 来生成。  
Seq 下发：生成 seq 模块三读三写储存下来。缓存模块主动轮训去拉最新的 Seq。  


架构图与流程大概如下：  


![](https://res2022.tiankonguse.com/2022/07/06/002.png)  



这样设计有几个问题。  


1、生成 seq 后，数据和 Seq 还没写入储存，缓存模块可能就得到最新的 seq，从而提前回源数据。  


理论上确实存在这个问题。  
实际上，这个架构上线了四五年，只有偶尔几次遇到这种情况导致数据大量回源，随后也自动恢复。  


仔细分析，原因有四。  


第一，下发 Seq 到储存写入 seq 的间隔是毫秒级别的，不同缓存机器的 Seq 下发时间也有差异。  


第二，只有某个 key 生成 Seq 但写储存失败时，才会导致大量回源。  
失败的概率是很小的。  


第三，某个 key 写储存失败，业务会进行失败重试，随后的更新会再次生成更大的Seq。  


第四，业务没有重试，大部分 key 的请求量不大，与大盘回源量相比，单个 Key 的量可以忽略。  



2、zookeeper 进行放号存在瓶颈，三读三写存在写量的瓶颈。  


这个写量瓶颈确实一个问题。  
但是我们的场景都是写少读多。  
所以，四五年来也没因为这个导致啥问题。  







加油，健康人。  


《完》  


-EOF-  



本文公众号：天空的代码世界  
个人微信号：tiankonguse  
公众号ID：tiankonguse-code  
  

